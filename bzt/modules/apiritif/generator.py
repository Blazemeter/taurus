"""
Copyright 2018 BlazeMeter Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import ast
import math
import re
import string
from collections import OrderedDict

import astunparse

from bzt import TaurusConfigError, TaurusInternalException
from bzt.engine import Scenario
from bzt.requests_model import HTTPRequest, HierarchicRequestParser, TransactionBlock, \
    SetVariables, IncludeScenarioBlock
from bzt.six import parse, string_types, iteritems, text_type, PY2
from bzt.utils import dehumanize_time, ensure_is_dict
from .ast_helpers import ast_attr, ast_call, gen_empty_line_stmt, gen_store, gen_subscript
from .jmeter_functions import JMeterExprCompiler


def normalize_class_name(text):
    allowed_chars = "%s%s%s" % (string.digits, string.ascii_letters, '_')
    split_separator = re.split(r'[\-_]', text)
    return ''.join([capitalize_class_name(part, allowed_chars) for part in split_separator])


def capitalize_class_name(text, allowed_chars):
    return filter_string(text, allowed_chars).capitalize()


def filter_string(text, allowed_chars):
    return ''.join(c for c in text if c in allowed_chars)


def normalize_method_name(text):
    allowed_chars = "%s%s%s" % (string.digits, string.ascii_letters, '- ')
    return filter_string(text, allowed_chars).replace(' ', '_').replace('-', '_')


def create_class_name(label):
    return 'TestAPI' if label.startswith('autogenerated') else 'Test%s' % normalize_class_name(label)


def create_method_name(label):
    return 'test_requests' if label.startswith('autogenerated') else normalize_method_name(label)


class ApiritifScriptGenerator(object):
    BYS = {
        'xpath': "XPATH",
        'css': "CSS_SELECTOR",
        'name': "NAME",
        'id': "ID",
        'linktext': "LINK_TEXT"
    }

    TO_BYS = {
        'byxpath': "xpath",
        'bycss': "css",
        'byname': "name",
        'byid': "id",
        'bylinktext': "linktext"
    }

    ACTION_CHAINS = {
        'doubleclick': "double_click",
        'mousedown': "click_and_hold",
        'mouseup': "release",
        'mousemove': "move_to_element",
        'mouseover': "move_to_element",
        'mouseout': "move_to_element_with_offset"
    }

    ACTIONS = "|".join(['click', 'doubleClick', 'mouseDown', 'mouseUp', 'mouseMove', 'mouseOut',
                        'mouseOver', 'select', 'wait', 'keys', 'pause', 'clear', 'assert',
                        'assertText', 'assertValue', 'submit', 'close', 'script', 'editcontent',
                        'switch', 'switchFrame', 'go', 'echo', 'type', 'element', 'drag',
                        'storeText', 'storeValue', 'store', 'open', 'screenshot', 'rawCode',
                        'resize', 'maximize', 'alert'
                        ])

    EXECUTION_BLOCKS = "|".join(['if', 'loop'])

    # Python AST docs: https://greentreesnakes.readthedocs.io/en/latest/

    IMPORTS = """import os
import re
from %s import webdriver
from selenium.common.exceptions import NoSuchElementException, TimeoutException
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import Select
from selenium.webdriver.support import expected_conditions as econd
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
"""

    BY_TAGS = ("byName", "byID", "byCSS", "byXPath", "byLinkText")
    COMMON_TAGS = ("For", "Cookies", "Title", "Window", "Eval", "ByIdx", "String")

    ACCESS_TARGET = 'target'
    ACCESS_PLAIN = 'plain'
    SUPPORTED_BLOCKS = (HTTPRequest, TransactionBlock, SetVariables, IncludeScenarioBlock)

    def __init__(self, scenario, label, wdlog=None, executor=None,
                 ignore_unknown_actions=False, generate_markers=None,
                 capabilities=None, wd_addr=None, test_mode="selenium"):
        self.scenario = scenario
        self.selenium_extras = set()
        self.data_sources = list(scenario.get_data_sources())
        self.executor = executor
        self.label = label
        self.log = self.scenario.engine.log.getChild(self.__class__.__name__)
        self.tree = None
        self.verbose = False
        self.expr_compiler = JMeterExprCompiler(parent_log=self.log)
        self.service_methods = []

        self.remote_address = wd_addr
        self.capabilities = capabilities or {}
        self.window_size = None
        self.wdlog = wdlog
        self.browser = None
        self.appium = False
        self.ignore_unknown_actions = ignore_unknown_actions
        self.generate_markers = generate_markers
        self.test_mode = test_mode

    def _parse_action_params(self, expr, name):
        res = expr.match(name)
        if not res:
            msg = "Unsupported action: %s" % name
            if self.ignore_unknown_actions:
                self.log.warning(msg)
                return
            else:
                raise TaurusConfigError(msg)

        atype = res.group(1).lower()
        tag = res.group(2).lower() if res.group(2) else ""
        selector = None
        if len(res.groups()) > 3:
            selector = res.group(4)

        return atype, tag, selector

    def _parse_string_action(self, name, param):
        tags = "|".join(self.BY_TAGS + self.COMMON_TAGS)
        all_actions = self.ACTIONS + "|" + self.EXECUTION_BLOCKS
        expr = re.compile("^(%s)(%s)?(\(([\S\s]*)\))?$" % (all_actions, tags), re.IGNORECASE)
        atype, tag, selector = self._parse_action_params(expr, name)
        value = None
        selectors = []
        # hello, reviewer!
        if selector:
            if selector.startswith('"') and selector.endswith('"'):
                selector = selector[1:-1]
            elif selector.startswith("'") and selector.endswith("'"):
                selector = selector[1:-1]
        else:
            selector = ""

        # Need to shuffle the variables to get the same output for both of the versions of
        # action types, this is unfortunately cumbersome as the param/value can be on different
        # places:
        # action_name(selector): param
        # action_name(param)
        # action_name(value): param, e.g. storeString(value): var_name
        if selector:
            if tag in self.TO_BYS.keys():
                tag_name = self.TO_BYS[tag]
                selectors = [{tag_name: selector}]
            elif not param:
                param = selector
            else:
                value = selector

        if atype == "drag":
            # param should be e.g. elementByXPath(/xpath)
            element_action = self._parse_action(param)
            selectors = (selectors, element_action[4])
        elif atype == "switchframe":
            # for switchFrameByName we need to get the param
            param = selector

        return atype, tag, param, value, selectors

    def _parse_dict_action(self, action_config):
        name = action_config["type"]
        selectors = action_config.get("locators")
        if action_config.get("source") and action_config.get("target"):
            selectors = (action_config.get("source"), action_config.get("target"))
        param = action_config["param"]
        value = action_config["value"]
        tags = "|".join(self.COMMON_TAGS) + "|ByName"   # ByName is needed in switchFrameByName
        expr = re.compile("^(%s)(%s)?$" % (self.ACTIONS, tags), re.IGNORECASE)
        action_params = self._parse_action_params(expr, name)

        return action_params[0], action_params[1], param, value, selectors

    def _parse_action(self, action_config):
        if isinstance(action_config, string_types):
            name = action_config
            param = None
        elif isinstance(action_config, dict):
            if action_config.get("type"):
                return self._parse_dict_action(action_config)
            block = self._get_execution_block(action_config)
            if len(block) == 1:
                name, param = (block[0], action_config.get(block[0]))
            else:
                name, param = next(iteritems(action_config))
        else:
            raise TaurusConfigError("Unsupported value for action: %s" % action_config)

        return self._parse_string_action(name, param)

    def _get_execution_block(self, action_config):
        # get the list of execution blocks in this action if there are any or empty list
        return list(set(action_config.keys()).intersection(self.EXECUTION_BLOCKS.split("|")))

    @staticmethod
    def _gen_dynamic_locator(var_w_locator):
        return ast_call(
            func=ast_attr("self.driver.find_element"),
            args=[
                gen_subscript(var_w_locator, 0),
                gen_subscript(var_w_locator, 1)
            ])

    def _gen_get_locators(self, var_name, locators):
        args = []
        for loc in locators:
            locator_type = list(loc.keys())[0]
            locator_value = loc[locator_type]
            args.append(ast.Dict([ast.Str(locator_type)], [self._gen_expr(locator_value)]))

        return ast.Assign(
            targets=[ast.Name(id=var_name, ctx=ast.Store())],
            value=ast_call(func="self.loc_mng.get_locator",
                           args=[ast.List(elts=args)]))

    def _gen_locator(self, tag, selector):
        return ast_call(
            func=ast_attr("self.driver.find_element"),
            args=[
                ast_attr("By.%s" % self.BYS[tag]),
                self._gen_expr(selector)])

    def _gen_window_mngr(self, atype, param):
        self.selenium_extras.add("WindowManager")
        elements = []
        if atype == "switch":
            elements.append(ast_call(
                func=ast_attr("self.wnd_mng.switch"),
                args=[self._gen_expr(param)]))
        elif atype == "resize":
            if not re.compile(r"\d+,\d+").match(param):
                if re.compile(r"\d+, \d+").match(param):
                    param = param.replace(', ', ',')
                else:
                    return elements
            x, y = param.split(",")
            elements.append(ast_call(
                func=ast_attr("self.driver.set_window_size"),
                args=[self._gen_expr(x), self._gen_expr(y)]))
        elif atype == "maximize":
            args = []
            elements.append(ast_call(
                func=ast_attr("self.driver.maximize_window"),
                args=args))
        elif atype == "open":
            elements.append(ast_call(
                func=ast_attr("self.driver.execute_script"),
                args=[self._gen_expr("window.open('%s');" % param)]))
        elif atype == "close":
            args = []
            if param:
                args.append(self._gen_expr(param))
            elements.append(ast_call(
                func=ast_attr("self.wnd_mng.close"),
                args=args))
        return elements

    def _gen_frame_mngr(self, tag, selector):
        self.selenium_extras.add("FrameManager")
        elements = []  # todo: byid/byidx disambiguation?
        if tag == "byidx" or selector.startswith("index=") or selector in ["relative=top", "relative=parent"]:
            if tag == "byidx":
                selector = "index=%s" % selector

            elements.append(ast_call(
                func=ast_attr("self.frm_mng.switch"),
                args=[ast.Str(selector)]))
        else:
            if tag == "byname":
                tag = "name"
            elements.append(ast_call(
                func=ast_attr("self.frm_mng.switch"),
                args=[self._gen_locator(tag, selector)]))
        return elements

    def _gen_chain_mngr(self, atype, selectors):
        elements = []
        if atype in self.ACTION_CHAINS:
            elements.append(self._gen_get_locators("var_loc_chain", selectors))
            locator = self._gen_dynamic_locator("var_loc_chain")
            operator = ast_attr(fields=(
                ast_call(func="ActionChains", args=[ast_attr("self.driver")]),
                self.ACTION_CHAINS[atype.lower()]))
            args = [locator, ast.Num(-10), ast.Num(-10)] if atype == "mouseout" else [locator]
            elements.append(ast_call(
                func=ast_attr(
                    fields=(
                        ast_call(
                            func=operator,
                            args=args),
                        "perform"))))
        elif atype == "drag":
            if not selectors or not selectors[0]:
                raise TaurusConfigError("Can not generate action for 'drag'. Source is empty.")
            if not selectors[1]:
                raise TaurusConfigError("Can not generate action for 'drag'. Target is empty.")
            source = selectors[0]
            target = selectors[1]

            elements = [self._gen_get_locators("source", source),
                        self._gen_get_locators("target", target)]

            operator = ast_attr(
                fields=(
                    ast_call(
                        func="ActionChains",
                        args=[ast_attr("self.driver")]),
                    "drag_and_drop"))
            elements.append(ast_call(
                func=ast_attr(
                    fields=(
                        ast_call(
                            func=operator,
                            args=[self._gen_dynamic_locator("source"),
                                  self._gen_dynamic_locator("target")]),
                        "perform"))))
        return elements

    def _gen_assert_store_mngr(self, atype, tag, name, value, selectors):
        elements = []
        if not name:
            raise TaurusConfigError("Missing param for %s action." % atype)
        if tag == 'title':
            if atype.startswith('assert'):
                elements.append(ast_call(
                    func=ast_attr("self.assertEqual"),
                    args=[ast_attr("self.driver.title"), self._gen_expr(name)]))
            else:
                elements.append(gen_store(
                    name=name.strip(),
                    value=self._gen_expr(ast_attr("self.driver.title"))))
        elif atype == 'store' and tag == 'string':
            elements.append(gen_store(
                name=name.strip(),
                value=self._gen_expr(value.strip())))
        elif atype == 'assert' and tag == 'eval':
            elements.append(ast_call(
                func=ast_attr("self.assertTrue"),
                args=[self._gen_eval_js_expression(name), ast.Str(name)]))
        elif atype == 'store' and tag == 'eval':
            elements.append(
                gen_store(
                    name=name.strip(),
                    value=self._gen_eval_js_expression(value))
            )
        else:
            target = None

            if atype in ["asserttext", "storetext"]:
                target = "innerText"
            elif atype in ["assertvalue", "storevalue"]:
                target = "value"

            if target:
                elements.append(self._gen_get_locators("var_loc_as", selectors))
                locator_attr = ast_call(
                    func=ast_attr(
                        fields=(
                            self._gen_dynamic_locator("var_loc_as"),
                            "get_attribute")),
                    args=[ast.Str(target)])

                if atype.startswith("assert"):
                    elements.append(ast_call(
                        func=ast_attr(fields="self.assertEqual"),
                        args=[
                            ast_call(
                                func=ast_attr(
                                    fields=(
                                        self._gen_expr(locator_attr),
                                        "strip"))),
                            ast_call(
                                func=ast_attr(
                                    fields=(
                                        self._gen_expr(name),
                                        "strip")))]))
                elif atype.startswith('store'):
                    elements.append(gen_store(
                        name=name.strip(),
                        value=self._gen_expr(locator_attr)))

        return elements

    def _gen_keys_mngr(self, atype, param, selectors):
        elements = []
        args = []
        action = None
        elements.append(self._gen_get_locators("var_loc_keys", selectors))

        if atype == "click":
            action = "click"
        elif atype == "submit":
            action = "submit"
        elif atype in ["keys", "type"]:
            if atype == "type":
                elements.append(ast_call(
                    func=ast_attr(
                        fields=(
                            self._gen_dynamic_locator("var_loc_keys"),
                            "clear"))))
            action = "send_keys"
            if isinstance(param, (string_types, text_type)) and param.startswith("KEY_"):
                args = [ast_attr("Keys.%s" % param.split("KEY_")[1])]
            else:
                args = [self._gen_expr(str(param))]

        if action:
            elements.append(ast_call(
                func=ast_attr(
                    fields=(
                        self._gen_dynamic_locator("var_loc_keys"),
                        action)),
                args=args))
        return elements

    def _gen_edit_mngr(self, param, locators):
        if not param:
            raise TaurusConfigError("Missing param for editContent action.")
        var_name = "var_edit_content"

        elements = [self._gen_get_locators(var_name, locators)]
        locator = self._gen_dynamic_locator(var_name)
        tag = gen_subscript(var_name, 0)
        selector = gen_subscript(var_name, 1)

        exc_type = ast_call(
            func="NoSuchElementException",
            args=[
                ast.BinOp(
                    left=ast.Str("The element (%s: %r) is not a contenteditable element"),
                    op=ast.Mod(),
                    right=ast.Tuple(elts=[tag, selector]))
            ]
        )

        if PY2:
            raise_kwargs = {
                "type": exc_type,
                "inst": None,
                "tback": None
            }
        else:
            raise_kwargs = {
                "exc": exc_type,
                "cause": None}

        body = ast.Expr(ast_call(func=ast_attr("self.driver.execute_script"),
                                 args=[
                                     ast.BinOp(
                                         left=ast.Str("arguments[0].innerHTML = '%s';"),
                                         op=ast.Mod(),
                                         right=self._gen_expr(param.strip())),
                                     locator]))

        element = ast.If(
            test=ast_call(
                func=ast_attr(
                    fields=(locator, "get_attribute")),
                args=[ast.Str("contenteditable")]),
            body=[body],
            orelse=[ast.Raise(**raise_kwargs)])

        elements.append(element)
        return elements

    def _gen_screenshot_mngr(self, param):
        elements = []
        if param:
            elements.append(ast_call(
                func=ast_attr("self.driver.save_screenshot"),
                args=[self._gen_expr(param)]))
        else:
            elements.append(ast.Assign(
                targets=[ast.Name(id="filename")],
                value=ast_call(
                    func=ast_attr("os.path.join"),
                    args=[
                        ast_call(
                            func=ast_attr("os.getenv"),
                            args=[ast.Str('TAURUS_ARTIFACTS_DIR')]),
                        ast.BinOp(
                            left=ast.Str('screenshot-%d.png'),
                            op=ast.Mod(),
                            right=ast.BinOp(
                                left=ast_call(func="time"),
                                op=ast.Mult(),
                                right=ast.Num(1000)))])))
            elements.append(ast_call(
                func=ast_attr("self.driver.save_screenshot"),
                args=[ast.Name(id="filename")]))
        return elements

    def _gen_alert(self, param):
        elements = []
        switch, args = "self.driver.switch_to.alert.", []
        if param == "OK":
            elements.append(ast_call(
                func=ast_attr(switch + "accept"),
                args=args))
        elif param == "Dismiss":
            elements.append(ast_call(
                func=ast_attr(switch + "dismiss"),
                args=args))
        return elements

    def _gen_wait_sleep_mngr(self, atype, tag, param, selectors):
        elements = []
        mode = "visibility" if param == 'visible' else 'presence'

        if atype == 'wait':
            exc = TaurusConfigError("wait action requires timeout in scenario: \n%s" % self.scenario)
            timeout = dehumanize_time(self.scenario.get("timeout", exc))
            locator_type = list(selectors[0].keys())[0]
            locator_value = selectors[0][locator_type]
            errmsg = "Element %r:%r failed to appear within %ss" % (locator_type, locator_value,
                                                                    timeout)

            elements.append(self._gen_get_locators("var_loc_wait", selectors))

            elements.append(ast_call(
                func=ast_attr(
                    fields=(
                        ast_call(
                            func="WebDriverWait",
                            args=[
                                ast_attr("self.driver"),
                                ast.Num(timeout)]),
                        "until")),
                args=[
                    ast_call(
                        func=ast_attr("econd.%s_of_element_located" % mode),
                        args=[
                            ast.Tuple(
                                elts=[
                                    gen_subscript("var_loc_wait", 0),
                                    gen_subscript("var_loc_wait", 1)
                                    ])]),
                    ast.Str(errmsg)]))

        elif atype == 'pause' and tag == 'for':
            elements.append(ast_call(
                func="sleep",
                args=[ast.Num(dehumanize_time(param))]))

        return elements

    def _gen_select_mngr(self, param, selectors):
        elements = [self._gen_get_locators("var_loc_select", selectors), ast_call(
            func=ast_attr(
                fields=(
                    ast_call(func="Select", args=[self._gen_dynamic_locator("var_loc_select")]),
                    "select_by_visible_text")),
            args=[self._gen_expr(param)])]
        return elements

    def _gen_action(self, action_config):
        action = self._parse_action(action_config)
        if action:
            atype, tag, param, value, selectors = action
        else:
            atype = tag = param = value = selectors = None

        action_elements = []

        if tag == "window":
            action_elements.extend(self._gen_window_mngr(atype, param))
        elif atype == "switchframe":
            action_elements.extend(self._gen_frame_mngr(tag, param))
        elif atype in self.ACTION_CHAINS or atype == "drag":
            action_elements.extend(self._gen_chain_mngr(atype, selectors))
        elif atype == "select":
            action_elements.extend(self._gen_select_mngr(param, selectors))
        elif atype is not None and (atype.startswith("assert") or atype.startswith("store")):
            action_elements.extend(self._gen_assert_store_mngr(atype, tag, param, value, selectors))

        elif atype in ("click", "type", "keys", "submit"):
            action_elements.extend(self._gen_keys_mngr(atype, param, selectors))

        elif atype == 'echo' and tag == 'string':
            if len(param) > 0 and not selectors:
                action_elements.append(ast_call(
                    func="print",
                    args=[self._gen_expr(param.strip())]))

        elif atype == "script" and tag == "eval":
            action_elements.append(ast_call(func=ast_attr("self.driver.execute_script"),
                                            args=[self._gen_expr(param)]))
        elif atype == "rawcode":
            action_elements.append(ast.parse(param))
        elif atype == 'go':
            if param:
                action_elements.append(ast_call(func=ast_attr("self.driver.get"),
                                                args=[self._gen_expr(param.strip())]))
        elif atype == "editcontent":
            action_elements.extend(self._gen_edit_mngr(param, selectors))
        elif atype in ('wait', 'pause'):
            action_elements.extend(self._gen_wait_sleep_mngr(atype, tag, param, selectors))
        elif atype == 'clear' and tag == 'cookies':
            action_elements.append(ast_call(
                func=ast_attr("self.driver.delete_all_cookies")))
        elif atype == 'screenshot':
            action_elements.extend(self._gen_screenshot_mngr(param))
        elif atype == 'alert':
            action_elements.extend(self._gen_alert(param))
        elif atype == 'if':
            action_elements.append(self._gen_condition_mngr(param, action_config))
        elif atype == 'loop':
            action_elements.append(self._gen_loop_mngr(action_config))

        if not action_elements and not self.ignore_unknown_actions:
            raise TaurusInternalException("Could not build code for action: %s" % action_config)

        return [ast.Expr(element) for element in action_elements]

    def _gen_loop_mngr(self, action_config):
        exc = TaurusConfigError("Loop must contain start, end and do")
        start = action_config.get('start', exc)
        end = action_config.get('end', exc)
        step = action_config.get('step') or 1
        end = end + 1 if step > 0 else end - 1
        elements = []

        body = [
            ast.Assign(
                targets=[self._gen_expr("${%s}" % action_config['loop'])],
                value=ast_call(func=ast_attr("str"), args=[ast.Name(id=action_config['loop'])]))
        ]
        for action in action_config.get('do', exc):
            body.append(self._gen_action(action))

        args = [ast.Num(start), ast.Num(end)]
        if step != 1:
            args.append(ast.Num(step))

        elements.append(
            ast.For(target=ast.Name(id=action_config.get('loop'),
                    ctx=ast.Store()),
                    iter=ast_call(func=ast_attr("range"),
                                  args=args),
                    body=body,
                    orelse=[]))

        return elements

    def _gen_eval_js_expression(self, js_expr):
        return ast_call(func=ast_attr("self.driver.execute_script"), args=[self._gen_expr("return %s;" % js_expr)])

    def _gen_condition_mngr(self, param, action_config):
        if not action_config.get('then'):
            raise TaurusConfigError("Missing then branch in if statement")

        test = ast.Assign(targets=[ast.Name(id='test', ctx=ast.Store())],
                          value=self._gen_eval_js_expression(param))

        body = []
        for action in action_config.get('then'):
            body.append(self._gen_action(action))

        orelse = []
        if action_config.get('else'):
            for action in action_config.get('else'):
                orelse.append(self._gen_action(action))

        return [test,
                [ast.If(
                    test=[ast.Name(id='test')],
                    body=body,
                    orelse=orelse)]]

    def _check_platform(self):
        mobile_browsers = ["chrome", "safari"]
        mobile_platforms = ["android", "ios"]

        browser = self.capabilities.get("browserName", "")
        browser = self.scenario.get("browser", browser)
        browser = browser.lower()  # todo: whether we should take browser as is? (without lower case)

        browser_platform = None
        if browser:
            browser_split = browser.split("-")
            browser = browser_split[0]
            browsers = ["firefox", "chrome", "ie", "opera"] + mobile_browsers
            if browser not in browsers:
                raise TaurusConfigError("Unsupported browser name: %s" % browser)
            if len(browser_split) > 1:
                browser_platform = browser_split[1]

        if self.remote_address:
            if browser and browser != "remote":
                msg = "Forcing browser to Remote, because of remote WebDriver address, use '%s' as browserName"
                self.log.warning(msg % browser)
                self.capabilities["browserName"] = browser
            browser = "remote"
            if self.generate_markers is None:  # if not set by user - set to true
                self.generate_markers = True
        elif browser in mobile_browsers and browser_platform in mobile_platforms:
            self.appium = True
            self.remote_address = "http://localhost:4723/wd/hub"
            self.capabilities["platformName"] = browser_platform
            self.capabilities["browserName"] = browser
            browser = "remote"  # Force to use remote web driver
        elif not browser:
            browser = "firefox"

        return browser

    def _get_scenario_timeout(self):
        return dehumanize_time(self.scenario.get("timeout", "30s"))

    def _gen_webdriver(self):
        self.log.debug("Generating setUp test method")
        browser = self._check_platform()

        headless = self.scenario.get("headless", False)
        headless_setup = []
        if headless:
            self.log.info("Headless mode works only with Selenium 3.8.0+, be sure to have it installed")
            headless_setup = [ast.Expr(
                ast_call(func=ast_attr("options.set_headless")))]

        body = [ast.Assign(targets=[ast_attr("self.driver")], value=ast_attr("None"))]

        if browser == 'firefox':
            body.append(ast.Assign(
                targets=[ast.Name(id="options")],
                value=ast_call(
                    func=ast_attr("webdriver.FirefoxOptions"))))
            body.extend(headless_setup)
            body.append(ast.Assign(
                targets=[ast.Name(id="profile")],
                value=ast_call(func=ast_attr("webdriver.FirefoxProfile"))))
            body.append(ast.Expr(
                ast_call(
                    func=ast_attr("profile.set_preference"),
                    args=[ast.Str("webdriver.log.file"), ast.Str(self.wdlog)])))

            body.append(ast.Assign(
                targets=[ast_attr("self.driver")],
                value=ast_call(
                    func=ast_attr("webdriver.Firefox"),
                    args=[ast.Name(id="profile")],
                    keywords=[ast.keyword(
                        arg="firefox_options",
                        value=ast.Name(id="options"))])))
        elif browser == 'chrome':
            body.append(ast.Assign(
                targets=[ast.Name(id="options")],
                value=ast_call(
                    func=ast_attr("webdriver.ChromeOptions"))))
            body.append(ast.Expr(
                ast_call(
                    func=ast_attr("options.add_argument"),
                    args=[ast.Str("%s" % "--no-sandbox")]
                )))
            body.append(ast.Expr(
                ast_call(
                    func=ast_attr("options.add_argument"),
                    args=[ast.Str("%s" % "--disable-dev-shm-usage")]
                )))
            body.extend(headless_setup)
            body.append(ast.Assign(
                targets=[ast_attr("self.driver")],
                value=ast_call(
                    func=ast_attr("webdriver.Chrome"),
                    keywords=[
                        ast.keyword(
                            arg="service_log_path",
                            value=ast.Str(self.wdlog)),
                        ast.keyword(
                            arg="chrome_options",
                            value=ast.Name(id="options"))])))
        elif browser == 'remote':
            keys = sorted(self.capabilities.keys())
            values = [str(self.capabilities[key]) for key in keys]
            body.append(ast.Assign(
                targets=[ast_attr("self.driver")],
                value=ast_call(
                    func=ast_attr("webdriver.Remote"),
                    keywords=[
                        ast.keyword(
                            arg="command_executor",
                            value=ast.Str(self.remote_address)),
                        ast.keyword(
                            arg="desired_capabilities",
                            value=ast.Dict(
                                keys=[ast.Str(key) for key in keys],
                                values=[ast.Str(value) for value in values]))])))
        else:
            if headless:
                self.log.warning("Browser %r doesn't support headless mode" % browser)

            body.append(ast.Assign(
                targets=[ast_attr("self.driver")],
                value=ast_call(
                    func=ast_attr("webdriver.%s" % browser))))  # todo bring 'browser' to correct case

        body.append(ast.Expr(
            ast_call(
                func=ast_attr("self.driver.implicitly_wait"),
                args=[ast.Num(self._get_scenario_timeout())])))

        mgr = "WindowManager"
        if mgr in self.selenium_extras:
            body.append(ast.Assign(
                targets=[ast_attr("self.wnd_mng")],
                value=ast_call(
                    func=ast.Name(id=mgr),
                    args=[ast_attr("self.driver")])))

        mgr = "FrameManager"
        if mgr in self.selenium_extras:
            body.append(ast.Assign(
                targets=[ast_attr("self.frm_mng")],
                value=ast_call(
                    func=ast.Name(id=mgr),
                    args=[ast_attr("self.driver")])))

        self.selenium_extras.add("LocatorsManager")
        mgr = "LocatorsManager"
        body.append(ast.Assign(
            targets=[ast_attr("self.loc_mng")],
            value=ast_call(
                func=ast.Name(id=mgr),
                args=[ast_attr("self.driver"), ast.Str(self._get_scenario_timeout())])))

        return body

    @staticmethod
    def _gen_impl_wait(timeout):
        return ast.Expr(
            ast_call(
                func=ast_attr("self.driver.implicitly_wait"),
                args=[ast.Num(dehumanize_time(timeout))]))

    def _gen_module(self):
        stmts = []

        if self.verbose:
            stmts.extend(self._gen_logging())

        stmts.extend(self._gen_data_source_readers())
        stmts.append(self._gen_classdef())

        stmts = self._gen_imports() + stmts  # todo: order is important (with classdef) because of self.appium setup

        return ast.Module(body=stmts)

    def _gen_imports(self):
        imports = [
            ast.Import(names=[ast.alias(name='logging', asname=None)]),
            ast.Import(names=[ast.alias(name='random', asname=None)]),
            ast.Import(names=[ast.alias(name='string', asname=None)]),
            ast.Import(names=[ast.alias(name='sys', asname=None)]),
            ast.Import(names=[ast.alias(name='unittest', asname=None)]),
            ast.ImportFrom(
                module="time",
                names=[
                    ast.alias(name="time", asname=None),
                    ast.alias(name="sleep", asname=None)],
                level=0),
            gen_empty_line_stmt(),
            ast.Import(names=[ast.alias(name='apiritif', asname=None)]),  # or "from apiritif import http, utils"?
            gen_empty_line_stmt()]

        if self.test_mode == "selenium":
            if self.appium:
                source = "appium"
            else:
                source = "selenium"

            imports.append(ast.parse(self.IMPORTS % source).body)
            if self.selenium_extras:
                extra_names = [ast.alias(name=name, asname=None) for name in self.selenium_extras]
                imports.append(
                    ast.ImportFrom(
                        module="bzt.resources.selenium_extras",
                        names=extra_names,
                        level=0))

        return imports

    def _gen_data_source_readers(self):
        readers = []
        for idx, source in enumerate(self.data_sources, start=1):
            keywords = []

            if "fieldnames" in source:
                fieldnames = ast.keyword()
                fieldnames.arg = "fieldnames"
                str_names = source.get("fieldnames").split(",")
                fieldnames.value = ast.List(elts=[ast.Str(s=fname) for fname in str_names])
                keywords.append(fieldnames)

            if "loop" in source:
                loop = ast.keyword()
                loop.arg = "loop"
                loop.value = ast.Name(id=source.get("loop"))
                keywords.append(loop)

            if "quoted" in source:
                quoted = ast.keyword()
                quoted.arg = "quoted"
                quoted.value = ast.Name(id=source.get("quoted"))
                keywords.append(quoted)

            if "delimiter" in source:
                delimiter = ast.keyword()
                delimiter.arg = "delimiter"
                delimiter.value = ast.Str(s=source.get("delimiter"))
                keywords.append(delimiter)

            csv_file = self.scenario.engine.find_file(source["path"])
            reader = ast.Assign(
                targets=[ast.Name(id="reader_%s" % idx)],
                value=ast_call(
                    func=ast_attr("apiritif.CSVReaderPerThread"),
                    args=[ast.Str(s=csv_file)],
                    keywords=keywords))

            readers.append(reader)

        if readers:
            readers.append(gen_empty_line_stmt())

        return readers

    def _gen_classdef(self):
        class_body = [self._gen_test_methods()]
        class_body = [self._gen_class_setup()] + class_body     # order is important for selenium_extras set

        if self.test_mode == "selenium":
            class_body.append(self._gen_class_teardown())

        return ast.ClassDef(
            name=create_class_name(self.label),
            bases=[ast_attr("unittest.TestCase")],
            body=class_body,
            keywords=[],
            starargs=None,
            kwargs=None,
            decorator_list=[])

    def _gen_class_setup(self):
        data_sources = [self._gen_default_vars()]
        for idx in range(len(self.data_sources)):
            data_sources.append(ast.Expr(ast_call(func=ast_attr("reader_%s.read_vars" % (idx + 1)))))

        for idx in range(len(self.data_sources)):
            extend_vars = ast_call(
                func=ast_attr("self.vars.update"),
                args=[ast_call(
                    func=ast_attr("reader_%s.get_vars" % (idx + 1)))])
            data_sources.append(ast.Expr(extend_vars))

        if self.test_mode == "apiritif":
            target_init = self._gen_api_target()
        else:
            target_init = self._gen_webdriver()

        handlers = []
        if self.generate_markers:
            func_name = "add_flow_markers"
            self.selenium_extras.add(func_name)
            handlers.append(ast.Expr(ast_call(func=func_name)))

        stored_vars = {"func_mode": str(self.executor.engine.is_functional_mode())}
        if target_init:
            if self.test_mode == "selenium":
                stored_vars["driver"] = "self.driver"

        has_ds = bool(list(self.scenario.get_data_sources()))
        stored_vars['scenario_name'] = [ast.Str(self.label)]
        if has_ds:
            stored_vars['data_sources'] = str(has_ds)

        store_call = ast_call(
            func=ast_attr("apiritif.put_into_thread_store"),
            keywords=[ast.keyword(arg=key, value=ast_attr(stored_vars[key])) for key in stored_vars],
            args=[])

        store_block = [ast.Expr(store_call)]

        setup = ast.FunctionDef(
            name="setUp",
            args=[ast_attr("self")],
            body=data_sources + target_init + handlers + store_block,
            decorator_list=[])
        return [setup, gen_empty_line_stmt()]

    def _gen_class_teardown(self):
        body = [
            ast.If(
                test=ast_attr("self.driver"),
                body=ast.Expr(ast_call(func=ast_attr("self.driver.quit"))), orelse=[])]

        return ast.FunctionDef(name="tearDown", args=[ast_attr("self")], body=body, decorator_list=[])

    def _gen_test_methods(self):
        methods = []
        slave_methods_names = []

        requests = self.scenario.get_requests(parser=HierarchicRequestParser, require_url=False)

        number_of_digits = int(math.log10(len(requests))) + 1
        for index, request in enumerate(requests, start=1):
            if not isinstance(request, self.SUPPORTED_BLOCKS):
                msg = "Apiritif script generator doesn't support '%s' blocks, skipping"
                self.log.warning(msg, request.NAME)
                continue

            # convert top-level http request to transaction
            if isinstance(request, HTTPRequest):
                request = TransactionBlock(
                    name=request.label,
                    requests=[request],
                    include_timers=[],
                    config=request.config,
                    scenario=request.scenario)

            if isinstance(request, TransactionBlock):
                body = [self._gen_transaction(request)]
                label = create_method_name(request.label[:40])
            elif isinstance(request, IncludeScenarioBlock):
                body = [self._gen_transaction(request)]
                label = create_method_name(request.scenario_name)
            elif isinstance(request, SetVariables):
                body = self._gen_set_vars(request)
                label = request.config.get("label", "set_variables")
            else:
                return

            counter = str(index).zfill(number_of_digits)
            method_name = '_' + counter + '_' + label

            if isinstance(request, SetVariables):
                self.service_methods.append(label)  # for sample excluding

            methods.append(self._gen_test_method(method_name, body))
            slave_methods_names.append(method_name)

        methods.append(self._gen_master_test_method(slave_methods_names))
        return methods

    def _gen_set_vars(self, request):
        res = []
        for name in sorted(request.mapping.keys()):
            res.append(ast.Assign(
                targets=[self._gen_expr("${%s}" % name)],
                value=ast.Str(s="%s" % request.mapping[name])))

        return res

    def _gen_master_test_method(self, slave_method_names):
        if not slave_method_names:
            raise TaurusConfigError("Supported trasactions not found, test is empty")

        body = []
        for slave_name in slave_method_names:
            body.append(ast.Expr(ast_call(func=ast_attr("self." + slave_name))))

        name = 'test_' + create_method_name(self.label)
        return self._gen_test_method(name=name, body=body)

    @staticmethod
    def _gen_test_method(name, body):
        # 'test_01_get_posts'
        return ast.FunctionDef(
            name=name,
            args=[ast.Name(id='self', ctx=ast.Param())],
            body=body,
            decorator_list=[])

    def _gen_expr(self, value):
        return self.expr_compiler.gen_expr(value)

    def _gen_target_setup(self, key, value):
        return ast.Expr(ast_call(
            func=ast_attr("self.target.%s" % key),
            args=[self._gen_expr(value)]))

    def _access_method(self):
        keepalive = self.scenario.get("keepalive", None)
        default_address = self.scenario.get("default-address", None)
        store_cookie = self.scenario.get("store-cookie", None)

        if default_address is not None or keepalive or store_cookie:
            return ApiritifScriptGenerator.ACCESS_TARGET
        else:
            return ApiritifScriptGenerator.ACCESS_PLAIN

    def _gen_api_target(self):
        keepalive = self.scenario.get("keepalive", None)
        base_path = self.scenario.get("base-path", None)
        auto_assert_ok = self.scenario.get("auto-assert-ok", True)
        store_cookie = self.scenario.get("store-cookie", None)
        timeout = self.scenario.get("timeout", None)
        follow_redirects = self.scenario.get("follow-redirects", True)

        if keepalive is None:
            keepalive = True
        if store_cookie is None:
            store_cookie = True

        target = []
        if self._access_method() == ApiritifScriptGenerator.ACCESS_TARGET:

            target.extend([
                self._init_target(),
                self._gen_target_setup('keep_alive', keepalive),
                self._gen_target_setup('auto_assert_ok', auto_assert_ok),
                self._gen_target_setup('use_cookies', store_cookie),
                self._gen_target_setup('allow_redirects', follow_redirects),
            ])
            if base_path:
                target.append(self._gen_target_setup('base_path', base_path))
            if timeout is not None:
                target.append(self._gen_target_setup('timeout', dehumanize_time(timeout)))
            target.append(gen_empty_line_stmt())
        return target

    def _init_target(self):
        # todo: allow empty address in apiritif (HTTPTarget.__init__)
        default_address = self.scenario.get("default-address", "")

        target_call = ast_call(
            func=ast_attr("apiritif.http.target"),
            args=[self._gen_expr(default_address)])

        target = ast.Assign(
            targets=[ast_attr("self.target")],
            value=target_call)

        return target

    def _extract_named_args(self, req):
        named_args = OrderedDict()

        no_target = self._access_method() != ApiritifScriptGenerator.ACCESS_TARGET
        if req.timeout is not None:
            named_args['timeout'] = dehumanize_time(req.timeout)
        elif "timeout" in self.scenario and no_target:
            named_args['timeout'] = dehumanize_time(self.scenario.get("timeout"))

        follow_redirects = req.priority_option('follow-redirects', None)
        if follow_redirects is not None:
            named_args['allow_redirects'] = follow_redirects

        headers = {}
        headers.update(self.scenario.get("headers"))
        headers.update(req.headers)

        if headers:
            named_args['headers'] = self._gen_expr(headers)

        merged_headers = dict([(key.lower(), value) for key, value in iteritems(headers)])
        content_type = merged_headers.get("content-type")

        if content_type == 'application/json' and isinstance(req.body, (dict, list)):  # json request body
            named_args['json'] = self._gen_expr(req.body)
        elif req.method.lower() == "get" and isinstance(req.body, dict):  # request URL params (?a=b&c=d)
            named_args['params'] = self._gen_expr(req.body)
        elif isinstance(req.body, dict):  # form data
            named_args['data'] = self._gen_expr(list(iteritems(req.body)))
        elif isinstance(req.body, string_types):
            named_args['data'] = self._gen_expr(req.body)
        elif req.body:
            msg = "Cannot handle 'body' option of type %s: %s"
            raise TaurusConfigError(msg % (type(req.body), req.body))

        return named_args

    # generate transactions recursively
    def _gen_transaction(self, trans_conf, transaction_class = "apiritif.smart_transaction"):
        body = []
        if isinstance(trans_conf, IncludeScenarioBlock):
            included = self.executor.get_scenario(trans_conf.scenario_name)
            included_requests = included.get_requests(parser=HierarchicRequestParser,
                                                      require_url=False)
            trans_conf = TransactionBlock(
                name=trans_conf.scenario_name,
                requests=included_requests,
                include_timers=[],
                config=included.data,
                scenario=included)
        for request in trans_conf.requests:
            if isinstance(request, TransactionBlock) or isinstance(request, IncludeScenarioBlock):
                body.append(self._gen_transaction(request, transaction_class="apiritif.transaction"))
            elif isinstance(request, SetVariables):
                body.append(self._gen_set_vars(request))
            else:
                body.append(self._gen_http_request(request))

        # if self.test_mode == "selenium":    # todo: remove it?
        #    transaction_class += "_logged"

        transaction = ast.With(
            context_expr=ast_call(
                func=ast_attr(transaction_class),
                args=[self._gen_expr(trans_conf.label)]),
            optional_vars=None,
            body=body)

        return transaction

    def _gen_http_request(self, req):
        lines = []
        think_time = dehumanize_time(req.get_think_time())

        if req.url:
            if self.test_mode == "selenium":
                if req.timeout:
                    lines.append(self._gen_impl_wait(req.timeout))
                default_address = self.scenario.get("default-address")
                parsed_url = parse.urlparse(req.url)
                if default_address and not parsed_url.netloc:
                    url = default_address + req.url
                else:
                    url = req.url

                lines.append(ast.Expr(
                    ast_call(
                        func=ast_attr("self.driver.get"),
                        args=[self._gen_expr(url)])))

            else:
                method = req.method.lower()
                named_args = self._extract_named_args(req)

                if self._access_method() == ApiritifScriptGenerator.ACCESS_TARGET:
                    requestor = ast_attr("self.target")
                else:
                    requestor = ast_attr("apiritif.http")

                keywords = [ast.keyword(
                    arg=name,
                    value=self._gen_expr(value)) for name, value in iteritems(named_args)]

                lines.append(ast.Assign(
                    targets=[ast.Name(id="response")],
                    value=ast_call(
                        func=ast_attr((requestor, method)),
                        args=[self._gen_expr(req.url)],
                        keywords=keywords)))

        elif "actions" not in req.config:
            self.log.warning("'url' and/or 'actions' are mandatory for request but not found: '%s'", req.config)
            return [ast.Pass()]

        if self.test_mode == "selenium":
            for action in req.config.get("actions"):
                lines.extend(self._gen_action(action))

            if "assert" in req.config:
                lines.append(ast.Assign(
                    targets=[ast.Name(id="body")],
                    value=ast_attr("self.driver.page_source")))
                for assert_config in req.config.get("assert"):
                    lines.extend(self._gen_sel_assertion(assert_config))

        else:
            lines.extend(self._gen_assertions(req))
            lines.extend(self._gen_jsonpath_assertions(req))
            lines.extend(self._gen_xpath_assertions(req))

        lines.extend(self._gen_extractors(req))

        if think_time:
            lines.append(ast.Expr(
                ast_call(
                    func=ast_attr("sleep"),
                    args=[self._gen_expr(think_time)])))

        return lines

    def _gen_sel_assertion(self, assertion_config):
        self.log.debug("Generating assertion, config: %s", assertion_config)
        assertion_elements = []

        if isinstance(assertion_config, string_types):
            assertion_config = {"contains": [assertion_config]}

        for val in assertion_config["contains"]:
            regexp = assertion_config.get("regexp", True)
            reverse = assertion_config.get("not", False)
            subject = assertion_config.get("subject", "body")
            if subject != "body":
                raise TaurusConfigError("Only 'body' subject supported ")

            assert_message = "'%s' " % val
            if not reverse:
                assert_message += 'not '
            assert_message += 'found in BODY'

            if regexp:
                if reverse:
                    method = "self.assertEqual"
                else:
                    method = "self.assertNotEqual"
                assertion_elements.append(
                    ast.Assign(
                        targets=[ast.Name(id="re_pattern")],
                        value=ast_call(
                            func=ast_attr("re.compile"),
                            args=[ast.Str(val)])))

                assertion_elements.append(ast.Expr(
                    ast_call(
                        func=ast_attr(method),
                        args=[
                            ast.Num(0),
                            ast_call(
                                func=ast.Name(id="len"),
                                args=[ast_call(
                                    func=ast_attr("re.findall"),
                                    args=[ast.Name(id="re_pattern"), ast.Name(id="body")])]),
                            ast.Str("Assertion: %s" % assert_message)])))

            else:
                if reverse:
                    method = "self.assertNotIn"
                else:
                    method = "self.assertIn"
                assertion_elements.append(
                    ast.Expr(
                        ast_call(
                            func=ast_attr(method),
                            args=[
                                ast.Str(val),
                                ast.Name(id="body"),
                                ast.Str("Assertion: %s" % assert_message)])))

        return assertion_elements

    def _gen_default_vars(self):
        variables = self.scenario.get("variables")
        names = sorted(variables.keys())
        values = [variables[name] for name in names]

        return ast.Assign(
            targets=[ast_attr("self.vars")],
            value=ast.Dict(
                keys=[self._gen_expr(name) for name in names],
                values=[self._gen_expr(val) for val in values]))

    def _gen_assertions(self, request):
        stmts = []
        assertions = request.config.get("assert", [])
        for idx, assertion in enumerate(assertions):
            assertion = ensure_is_dict(assertions, idx, "contains")
            if not isinstance(assertion['contains'], list):
                assertion['contains'] = [assertion['contains']]
            subject = assertion.get("subject", Scenario.FIELD_BODY)
            if subject in (Scenario.FIELD_BODY, Scenario.FIELD_HEADERS):
                for member in assertion["contains"]:
                    func_table = {
                        (Scenario.FIELD_BODY, False, False): "assert_in_body",
                        (Scenario.FIELD_BODY, False, True): "assert_not_in_body",
                        (Scenario.FIELD_BODY, True, False): "assert_regex_in_body",
                        (Scenario.FIELD_BODY, True, True): "assert_regex_not_in_body",
                        (Scenario.FIELD_HEADERS, False, False): "assert_in_headers",
                        (Scenario.FIELD_HEADERS, False, True): "assert_not_in_headers",
                        (Scenario.FIELD_HEADERS, True, False): "assert_regex_in_headers",
                        (Scenario.FIELD_HEADERS, True, True): "assert_regex_not_in_headers",
                    }
                    method = func_table[(subject, assertion.get('regexp', True), assertion.get('not', False))]
                    stmts.append(ast.Expr(
                        ast_call(
                            func=ast_attr("response.%s" % method),
                            args=[self._gen_expr(member)])))

            elif subject == Scenario.FIELD_RESP_CODE:
                for member in assertion["contains"]:
                    method = "assert_status_code" if not assertion.get('not', False) else "assert_not_status_code"
                    stmts.append(ast.Expr(
                        ast_call(
                            func=ast_attr("response.%s" % method),
                            args=[self._gen_expr(member)])))
        return stmts

    def _gen_jsonpath_assertions(self, request):
        stmts = []
        jpath_assertions = request.config.get("assert-jsonpath", [])
        for idx, assertion in enumerate(jpath_assertions):
            assertion = ensure_is_dict(jpath_assertions, idx, "jsonpath")
            exc = TaurusConfigError('JSON Path not found in assertion: %s' % assertion)
            query = assertion.get('jsonpath', exc)
            expected = assertion.get('expected-value', None)
            method = "assert_not_jsonpath" if assertion.get('invert', False) else "assert_jsonpath"
            stmts.append(ast.Expr(
                ast_call(
                    func=ast_attr("response.%s" % method),
                    args=[self._gen_expr(query)],
                    keywords=[ast.keyword(arg="expected_value", value=self._gen_expr(expected))])))

        return stmts

    def _gen_xpath_assertions(self, request):
        stmts = []
        jpath_assertions = request.config.get("assert-xpath", [])
        for idx, assertion in enumerate(jpath_assertions):
            assertion = ensure_is_dict(jpath_assertions, idx, "xpath")
            exc = TaurusConfigError('XPath not found in assertion: %s' % assertion)
            query = assertion.get('xpath', exc)
            parser_type = 'html' if assertion.get('use-tolerant-parser', True) else 'xml'
            validate = assertion.get('validate-xml', False)
            method = "assert_not_xpath" if assertion.get('invert', False) else "assert_xpath"
            stmts.append(ast.Expr(
                ast_call(
                    func=ast_attr("response.%s" % method),
                    args=[self._gen_expr(query)],
                    keywords=[ast.keyword(arg="parser_type", value=self._gen_expr(parser_type)),
                              ast.keyword(arg="validate", value=self._gen_expr(validate))])))
        return stmts

    def _gen_extractors(self, request):
        stmts = []
        jextractors = request.config.get("extract-jsonpath")
        for varname in jextractors:
            cfg = ensure_is_dict(jextractors, varname, "jsonpath")
            stmts.append(ast.Assign(
                targets=[self.expr_compiler.gen_var_accessor(varname, ast.Store())],
                value=ast_call(
                    func=ast_attr("response.extract_jsonpath"),
                    args=[self._gen_expr(cfg['jsonpath']), self._gen_expr(cfg.get('default', 'NOT_FOUND'))])))

        extractors = request.config.get("extract-regexp")
        for varname in extractors:
            cfg = ensure_is_dict(extractors, varname, "regexp")
            # TODO: support non-'body' value of 'subject'
            stmts.append(ast.Assign(
                targets=[self.expr_compiler.gen_var_accessor(varname, ast.Store())],
                value=ast_call(
                    func=ast_attr("response.extract_regex"),
                    args=[self._gen_expr(cfg['regexp']), self._gen_expr(cfg.get('default', 'NOT_FOUND'))])))

        # TODO: css/jquery extractor?

        xpath_extractors = request.config.get("extract-xpath")
        for varname in xpath_extractors:
            cfg = ensure_is_dict(xpath_extractors, varname, "xpath")
            parser_type = 'html' if cfg.get('use-tolerant-parser', True) else 'xml'
            validate = cfg.get('validate-xml', False)
            stmts.append(ast.Assign(
                targets=[self.expr_compiler.gen_var_accessor(varname, ast.Store())],
                value=ast_call(
                    func=ast_attr("response.extract_xpath"),
                    args=[self._gen_expr(cfg['xpath'])],
                    keywords=[ast.keyword(arg="default", value=cfg.get('default', 'NOT_FOUND')),
                              ast.keyword(arg="parser_type", value=parser_type),
                              ast.keyword(arg="validate", value=validate)])))
        return stmts

    def _build_tree(self):
        mod = self._gen_module()
        mod.lineno = 0
        mod.col_offset = 0
        mod = ast.fix_missing_locations(mod)
        return mod

    def build_source_code(self):
        self.tree = self._build_tree()

    def save(self, filename):
        if PY2:
            with open(filename, 'wt') as fds:
                fds.write("# coding=utf-8\n")
                fds.write(astunparse.unparse(self.tree))
        else:
            with open(filename, 'wt', encoding='utf8') as fds:
                fds.write("# coding=utf-8\n")
                fds.write(astunparse.unparse(self.tree))

    def _gen_logging(self):
        set_log = ast.Assign(
            targets=[ast.Name(id="log")],
            value=ast_call(
                func=ast_attr("logging.getLogger"),
                args=[ast.Str(s="apiritif.http")]))
        add_handler = ast_call(
            func=ast_attr("log.addHandler"),
            args=[ast_call(
                func=ast_attr("logging.StreamHandler"),
                args=[ast_attr("sys.stdout")])])
        set_level = ast_call(
            func=ast_attr("log.setLevel"),
            args=[ast_attr("logging.DEBUG")])

        return [set_log, gen_empty_line_stmt(), add_handler,
                gen_empty_line_stmt(), set_level, gen_empty_line_stmt()]
