"""
Module holds Grinder code generator

Copyright 2019 BlazeMeter Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from bzt.requests_model import HTTPRequest
from bzt.six import iteritems
from bzt.utils import dehumanize_time
from .python import PythonGenerator


class GrinderScriptBuilder(PythonGenerator):
    IMPORTS = """
from net.grinder.script import Test
from net.grinder.script.Grinder import grinder
from net.grinder.plugin.http import HTTPRequest, HTTPPluginControl, HTTPUtilities
from HTTPClient import NVPair
"""

    def __init__(self, scenario, parent_logger):
        super(GrinderScriptBuilder, self).__init__(scenario, parent_logger)
        self.label = "BZT Requests"

    def build_source_code(self):
        self.log.debug("Generating Python script for Grinder")
        self.root.append(self.gen_comment("This script was generated by Taurus", indent=0))
        self.root.append(self.add_imports())

        self.root.append(self.gen_new_line())

        default_address = self.scenario.get("default-address")
        url_arg = "url=%r" % default_address if default_address else ""
        self.root.append(self.gen_statement('request = HTTPRequest(%s)' % url_arg, indent=0))
        self.root.append(self.gen_statement('test = Test(1, "%s")' % self.label, indent=0))
        self.root.append(self.gen_statement('test.record(request)', indent=0))

        self.root.append(self.gen_new_line())

        self.root.append(self.gen_statement("defaults = HTTPPluginControl.getConnectionDefaults()", indent=0))
        self.root.append(self.gen_statement("utilities = HTTPPluginControl.getHTTPUtilities()", indent=0))

        headers = self.scenario.get_headers()
        if not self.scenario.get("keepalive", True):
            headers['Connection'] = 'close'

        if headers:
            self.root.append(self.gen_statement("defaults.setDefaultHeaders([", indent=0))
            for header, value in iteritems(headers):
                self.root.append(self.gen_statement("NVPair(%r, %r)," % (header, value), indent=4))
            self.root.append(self.gen_statement("])", indent=0))

        global_timeout = dehumanize_time(self.scenario.get("timeout", None))
        if global_timeout:
            self.root.append(self.gen_statement("defaults.setTimeout(%s)" % int(global_timeout * 1000), indent=0))

        cookie_flag = int(self.scenario.get("store-cookie", True))
        self.root.append(self.gen_statement("defaults.setUseCookies(%s)" % cookie_flag, indent=0))

        self.root.append(self.gen_new_line())

        self.root.append(self.gen_runner_class())

    @staticmethod
    def __list_to_nvpair_list(items):
        return "[" + ",".join("NVPair(%r, %r)" % (header, value) for header, value in items) + "]"

    def gen_runner_class(self):
        runner_classdef = self.gen_class_definition("TestRunner", ["object"])

        sleep_method = self.gen_method_definition("rampUpSleeper", ["self"])
        sleep_method.append(self.gen_statement("if grinder.runNumber != 0: return"))
        sleep_method.append(self.gen_statement("tprops = grinder.properties.getPropertySubset('taurus.')"))
        sleep_method.append(self.gen_statement("inc = tprops.getDouble('ramp_up', 0)/tprops.getInt('concurrency', 1)"))
        sleep_method.append(self.gen_statement("sleep_time = int(1000 * grinder.threadNumber * inc)"))
        sleep_method.append(self.gen_statement("grinder.sleep(sleep_time, 0)"))
        sleep_method.append(self.gen_statement("if sleep_time: grinder.logger.info('slept for %sms' % sleep_time)"))
        sleep_method.append(self.gen_statement("else: grinder.logger.info('No sleep needed')"))
        sleep_method.append(self.gen_new_line())
        runner_classdef.append(sleep_method)

        main_method = self.gen_method_definition("__call__", ["self"])
        main_method.append(self.gen_statement("self.rampUpSleeper()"))

        for req in self.scenario.get_requests():
            if not isinstance(req, HTTPRequest):
                msg = "Grinder script generator doesn't support '%s' blocks, skipping"
                self.log.warning(msg, req.NAME)
                continue

            method = req.method.upper()
            url = req.url
            local_headers = req.headers

            params = "[]"
            headers = self.__list_to_nvpair_list(iteritems(local_headers))

            main_method.append(self.gen_statement("request.%s(%r, %s, %s)" % (method, url, params, headers)))

            think_time = dehumanize_time(req.priority_option('think-time'))
            if think_time:
                main_method.append(self.gen_statement("grinder.sleep(%s)" % int(think_time * 1000)))

        runner_classdef.append(main_method)

        return runner_classdef
