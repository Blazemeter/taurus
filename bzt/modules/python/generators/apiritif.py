"""
Copyright 2018 BlazeMeter Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import ast
import re
import string
from collections import OrderedDict

import astunparse
import math

from bzt import TaurusConfigError
from bzt.engine import Scenario
from bzt.requests_model import HTTPRequest, HierarchicRequestParser, TransactionBlock
from bzt.six import string_types, iteritems
from bzt.utils import PythonGenerator, dehumanize_time, ensure_is_dict
from .jmeter_functions import Base64DecodeFunction, UrlEncodeFunction, UuidFunction
from .jmeter_functions import TimeFunction, RandomFunction, RandomStringFunction, Base64EncodeFunction


def normalize_class_name(text):
    allowed_chars = "%s%s%s" % (string.digits, string.ascii_letters, '_')
    split_separator = re.split(r'[\-_]', text)
    return ''.join([capitalize_class_name(part, allowed_chars) for part in split_separator])


def capitalize_class_name(text, allowed_chars):
    return filter_string(text, allowed_chars).capitalize()


def filter_string(text, allowed_chars):
    return ''.join(c for c in text if c in allowed_chars)


def normalize_method_name(text):
    allowed_chars = "%s%s%s" % (string.digits, string.ascii_letters, '- ')
    return filter_string(text, allowed_chars).replace(' ', '_').replace('-', '_')


def create_class_name(label):
    return 'TestAPI' if label.startswith('autogenerated') else 'Test%s' % normalize_class_name(label)


def create_method_name(label):
    return 'test_requests' if label.startswith('autogenerated') else normalize_method_name(label)


class JMeterExprCompiler(object):
    def __init__(self, parent_log):
        self.log = parent_log.getChild(self.__class__.__name__)

    def gen_var_accessor(self, varname, ctx=None):
        if ctx is None:
            ctx = ast.Load()

        return ast.Subscript(
            value=ast.Name(id="self.vars", ctx=ast.Load()),
            slice=ast.Index(value=ast.Str(s=varname)),
            ctx=ctx
        )

    def gen_expr(self, value):
        if isinstance(value, bool):
            return ast.Name(id="True" if value else "False", ctx=ast.Load())
        elif isinstance(value, (int, float)):
            return ast.Num(n=value)
        elif isinstance(value, string_types):
            # if is has interpolation - break it into either a `"".format(args)` form or a Name node
            # otherwise - it's a string literal
            parts = re.split(r'(\$\{.*?\})', value)
            format_args = []
            for item in parts:
                if item:
                    if item.startswith("${") and item.endswith("}"):
                        value = value.replace(item, "{}")
                        compiled = self.translate_jmeter_expr(item[2:-1])
                        format_args.append(compiled)
            if format_args:
                if len(format_args) == 1 and value == "{}":
                    result = format_args[0]
                else:
                    result = ast.Call(
                        func=ast.Attribute(
                            value=ast.Str(s=value),
                            attr='format',
                            ctx=ast.Load(),
                        ),
                        args=format_args,
                        keywords=[],
                        starargs=None,
                        kwargs=None
                    )
            else:
                result = ast.Str(s=value)
            return result
        elif isinstance(value, type(None)):
            return ast.Name(id="None", ctx=ast.Load())
        elif isinstance(value, dict):
            items = sorted(list(iteritems(value)))
            return ast.Dict(keys=[self.gen_expr(k) for k, _ in items],
                            values=[self.gen_expr(v) for _, v in items])
        elif isinstance(value, list):
            return ast.List(elts=[self.gen_expr(val) for val in value], ctx=ast.Load())
        elif isinstance(value, tuple):
            return ast.Tuple(elts=[self.gen_expr(val) for val in value], ctx=ast.Load())
        elif isinstance(value, ast.AST):
            return value
        else:
            return value

    def translate_jmeter_expr(self, expr):
        """
        Translates JMeter expression into Apiritif-based Python expression.
        :type expr: str
        :return:
        """
        self.log.debug("Attempting to translate JMeter expression %r", expr)
        functions = {
            '__time': TimeFunction,
            '__Random': RandomFunction,
            '__RandomString': RandomStringFunction,
            '__base64Encode': Base64EncodeFunction,
            '__base64Decode': Base64DecodeFunction,
            '__urlencode': UrlEncodeFunction,
            '__UUID': UuidFunction,
        }
        regexp = r"(\w+)\((.*?)\)"
        args_re = r'(?<!\\),'
        match = re.match(regexp, expr)
        if match is None:  # doesn't look like JMeter func, translate as a var
            return self.gen_var_accessor(expr)

        varname, arguments = match.groups()

        if arguments is None:  # plain variable
            result = self.gen_var_accessor(varname)
        else:  # function call
            if not arguments:
                args = []
            else:
                # parse arguments: split by ',' but not '\,'
                args = [arg.strip() for arg in re.split(args_re, arguments)]

            if varname not in functions:  # unknown function
                return ast.Name(id=varname, ctx=ast.Load())

            self.log.debug("Translating function %s with arguments %s", varname, arguments)
            func = functions[varname](self)
            result = func.to_python(args)
            if result is None:
                result = ast.Name(id=varname, ctx=ast.Load())
        self.log.debug("Compile: %r -> %r", expr, result)
        return result


class ApiritifScriptGenerator(PythonGenerator):
    # Python AST docs: https://greentreesnakes.readthedocs.io/en/latest/

    ACCESS_TARGET = 'target'
    ACCESS_PLAIN = 'plain'

    def __init__(self, engine, scenario, label, parent_log):
        super(ApiritifScriptGenerator, self).__init__(scenario, parent_log)
        self.scenario = scenario
        self.engine = engine
        self.data_sources = list(scenario.get_data_sources())
        self.label = label
        self.log = parent_log.getChild(self.__class__.__name__)
        self.tree = None
        self.verbose = False
        self.expr_compiler = JMeterExprCompiler(parent_log=self.log)
        self.stored_vars = []

    @staticmethod
    def _gen_empty_line_stmt():
        return ast.Expr(value=ast.Name(id=""))  # hacky, but works

    def _gen_module(self):
        stmts = [self._gen_imports()]

        if self.verbose:
            stmts.extend(self._gen_logging())

        stmts.extend(self._gen_data_source_readers())
        stmts.extend(self._gen_module_setup())
        stmts.append(self._gen_classdef())
        return ast.Module(body=stmts)

    def _gen_imports(self):
        return [
            ast.Import(names=[ast.alias(name='logging', asname=None)]),
            ast.Import(names=[ast.alias(name='random', asname=None)]),
            ast.Import(names=[ast.alias(name='string', asname=None)]),
            ast.Import(names=[ast.alias(name='sys', asname=None)]),
            ast.Import(names=[ast.alias(name='time', asname=None)]),
            ast.Import(names=[ast.alias(name='unittest', asname=None)]),
            self._gen_empty_line_stmt(),
            ast.Import(names=[ast.alias(name='apiritif', asname=None)]),    # or "from apiritif import http, utils"?
            self._gen_empty_line_stmt()]

    def _gen_module_setup(self):
        target_init = self._gen_target()

        data_sources = [self._gen_default_vars()]
        for idx in range(len(self.data_sources)):
            reader = "reader_%s" % (idx + 1)
            func = ast.Attribute(value=ast.Name(id=reader), attr="read_vars")
            read_vars = ast.Call(func=func, args=[], starargs=None, kwargs=None, keywords=[])
            data_sources.append(ast.Expr(read_vars))

        for idx in range(len(self.data_sources)):
            reader_get_vars = ast.Attribute(value=ast.Name(id="reader_%s" % (idx + 1)), attr="get_vars")
            get_vars = ast.Call(func=reader_get_vars, args=[], starargs=None, kwargs=None,keywords=[])

            update = ast.Attribute(attr="update", value=ast.Name(id="vars"))

            extend_vars = ast.Call(func=update, args=[get_vars], starargs=None, kwargs=None, keywords=[])
            data_sources.append(ast.Expr(extend_vars))

        self.stored_vars = ['vars']
        if target_init:
            self.stored_vars.append('target')

        store_call = ast.Call(
                func=ast.Attribute(attr="put_into_thread_store", value=ast.Name(id="apiritif")),
                args=[ast.Name(id=var) for var in self.stored_vars],
                starargs=None,
                kwargs=None,
                keywords=[])

        store_block = [self._gen_empty_line_stmt(), ast.Expr(store_call)]

        setup = ast.FunctionDef(
            name="setup",
            args=[],
            body=target_init + data_sources + store_block,
            decorator_list=[])
        return [setup, self._gen_empty_line_stmt()]

    def _gen_data_source_readers(self):
        readers = []
        for idx, source in enumerate(self.data_sources, start=1):
            keywords = []

            if "fieldnames" in source:
                fieldnames = ast.keyword()
                fieldnames.arg = "fieldnames"
                str_names = source.get("fieldnames").split(",")
                fieldnames.value = ast.List(elts=[ast.Str(s=fname) for fname in str_names])
                keywords.append(fieldnames)

            if "loop" in source:
                loop = ast.keyword()
                loop.arg = "loop"
                loop.value = ast.Name(id=source.get("loop"))
                keywords.append(loop)

            if "quoted" in source:
                quoted = ast.keyword()
                quoted.arg = "quoted"
                quoted.value = ast.Name(id=source.get("quoted"))
                keywords.append(quoted)

            if "delimiter" in source:
                delimiter = ast.keyword()
                delimiter.arg = "delimiter"
                delimiter.value = ast.Str(s=source.get("delimiter"))
                keywords.append(delimiter)

            csv_file = self.engine.find_file(source["path"])
            reader = ast.Assign(
                targets=[ast.Name(id="reader_%s" % idx)],
                value=ast.Call(
                    func=ast.Name(id="apiritif.CSVReaderPerThread"),
                    args=[ast.Str(s=csv_file)],
                    starargs=None,
                    kwargs=None,
                    keywords=keywords))

            readers.append(reader)

        if readers:
            readers.append(self._gen_empty_line_stmt())

        return readers

    def _gen_classdef(self):
        class_body = [self._gen_class_setup()]
        class_body.extend(self._gen_test_methods())

        class_name = create_class_name(self.label)
        base = ast.Attribute(value=ast.Name(id='unittest', ctx=ast.Load()), attr='TestCase', ctx=ast.Load())
        return ast.ClassDef(
            name=class_name,
            bases=[base],
            body=class_body,
            keywords=[],
            starargs=None,
            kwargs=None,
            decorator_list=[])

    def _gen_class_setup(self):
        fields = ast.Tuple(elts=[ast.Name(id="self.%s" % var) for var in self.stored_vars])
        get_func = ast.Attribute(attr="get_from_thread_store", value=ast.Name(id="apiritif"))
        get_call = ast.Call(func=get_func, args=[], starargs=None, kwargs=None, keywords=[])

        get_expr = ast.Assign(targets=[fields], value=get_call)
        args = ast.arguments(args=[ast.Name(id="self")], defaults=[], vararg=None, kwarg=None)

        return ast.FunctionDef(name="setUp", args=args, body=[get_expr], decorator_list=[])

    def _gen_test_methods(self):
        requests = self.scenario.get_requests(parser=HierarchicRequestParser)

        number_of_digits = int(math.log10(len(requests))) + 1
        for index, request in enumerate(requests, start=1):
            if not isinstance(request, (HTTPRequest, TransactionBlock)):
                msg = "Apiritif script generator doesn't support '%s' blocks, skipping"
                self.log.warning(msg, request.NAME)
                continue

            # convert top-level http request to transaction
            if isinstance(request, HTTPRequest):
                request = TransactionBlock(
                    name=request.label,
                    requests=[request],
                    include_timers=[],
                    config=request.config,
                    scenario=request.scenario)

            label = create_method_name(request.label[:40])
            counter = str(index).zfill(number_of_digits)

            # 'test_01_get_posts'
            method_name = 'test_' + counter + '_' + label
            method = ast.FunctionDef(
                name=method_name,
                args=ast.arguments(
                    args=[ast.Name(id='self', ctx=ast.Param())],
                    defaults=[],
                    vararg=None,
                    kwonlyargs=[],
                    kw_defaults=[],
                    kwarg=None,
                    returns=None,
                ),
                body=[self._gen_transaction(request)],
                decorator_list=[],
            )

            yield method

    def gen_expr(self, value):
        return self.expr_compiler.gen_expr(value)

    def _gen_target_setup(self, key, value):
        return ast.Expr(value=ast.Call(
            func=ast.Attribute(value=ast.Name(id='target', ctx=ast.Load()), attr=key, ctx=ast.Load()),
            args=[self.gen_expr(value)],
            keywords=[],
            starargs=None,
            kwargs=None
        ))

    def _access_method(self):
        keepalive = self.scenario.get("keepalive", None)
        default_address = self.scenario.get("default-address", None)
        store_cookie = self.scenario.get("store-cookie", None)

        if default_address is not None or keepalive or store_cookie:
            return ApiritifScriptGenerator.ACCESS_TARGET
        else:
            return ApiritifScriptGenerator.ACCESS_PLAIN

    def _gen_target(self):
        keepalive = self.scenario.get("keepalive", None)
        base_path = self.scenario.get("base-path", None)
        auto_assert_ok = self.scenario.get("auto-assert-ok", True)
        store_cookie = self.scenario.get("store-cookie", None)
        timeout = self.scenario.get("timeout", None)
        follow_redirects = self.scenario.get("follow-redirects", True)

        if keepalive is None:
            keepalive = True
        if store_cookie is None:
            store_cookie = True

        target = []
        if self._access_method() == ApiritifScriptGenerator.ACCESS_TARGET:

            target.extend([
                self._init_target(),
                self._gen_target_setup('keep_alive', keepalive),
                self._gen_target_setup('auto_assert_ok', auto_assert_ok),
                self._gen_target_setup('use_cookies', store_cookie),
                self._gen_target_setup('allow_redirects', follow_redirects),
            ])
            if base_path:
                target.append(self._gen_target_setup('base_path', base_path))
            if timeout is not None:
                target.append(self._gen_target_setup('timeout', dehumanize_time(timeout)))
            target.append(self._gen_empty_line_stmt())
        return target

    def _init_target(self):
        default_address = self.scenario.get("default-address", None)

        http = ast.Attribute(
            value=ast.Name(id='apiritif', ctx=ast.Load()),
            attr='http',
            ctx=ast.Load())

        target_call = ast.Call(
            func=ast.Attribute(value=http, attr='target', ctx=ast.Load()),
            args=[self.gen_expr(default_address)],
            keywords=[],
            starargs=None,
            kwargs=None)

        target = ast.Assign(
            targets=[ast.Name(id="target", ctx=ast.Store())],
            value=target_call)

        return target

    def _extract_named_args(self, req):
        named_args = OrderedDict()

        no_target = self._access_method() != ApiritifScriptGenerator.ACCESS_TARGET
        if req.timeout is not None:
            named_args['timeout'] = dehumanize_time(req.timeout)
        elif "timeout" in self.scenario and no_target:
            named_args['timeout'] = dehumanize_time(self.scenario.get("timeout"))

        follow_redirects = req.priority_option('follow-redirects', None)
        if follow_redirects is not None:
            named_args['allow_redirects'] = follow_redirects

        headers = {}
        headers.update(self.scenario.get("headers"))
        headers.update(req.headers)

        if headers:
            named_args['headers'] = self.gen_expr(headers)

        merged_headers = dict([(key.lower(), value) for key, value in iteritems(headers)])
        content_type = merged_headers.get("content-type")

        if content_type == 'application/json' and isinstance(req.body, (dict, list)):  # json request body
            named_args['json'] = self.gen_expr(req.body)
        elif req.method.lower() == "get" and isinstance(req.body, dict):  # request URL params (?a=b&c=d)
            named_args['params'] = self.gen_expr(req.body)
        elif isinstance(req.body, dict):  # form data
            named_args['data'] = self.gen_expr(list(iteritems(req.body)))
        elif isinstance(req.body, string_types):
            named_args['data'] = self.gen_expr(req.body)
        elif req.body:
            msg = "Cannot handle 'body' option of type %s: %s"
            raise TaurusConfigError(msg % (type(req.body), req.body))

        return named_args

    # generate transactions recursively
    def _gen_transaction(self, trans_conf):
        body = []
        for request in trans_conf.requests:
            if isinstance(request, TransactionBlock):
                body.append(self._gen_transaction(request))
            else:
                body.append(self._gen_http_request(request))

        transaction = ast.With(
            context_expr=ast.Call(
                func=ast.Attribute(value=ast.Name(id='apiritif'), attr="transaction"),
                args=[self.gen_expr(trans_conf.label)],
                keywords=[],
                starargs=None,
                kwargs=None
            ),
            optional_vars=None,
            body=body)

        return transaction

    def _gen_http_request(self, req):
        lines = []
        method = req.method.lower()
        think_time = dehumanize_time(req.priority_option('think-time', default=None))
        named_args = self._extract_named_args(req)
        target = ast.Name(id='self.target', ctx=ast.Load())
        apiritif_http = ast.Attribute(value=ast.Name(id='apiritif', ctx=ast.Load()), attr='http', ctx=ast.Load())

        requestor = target if self._access_method() == ApiritifScriptGenerator.ACCESS_TARGET else apiritif_http

        lines.append(ast.Assign(
            targets=[
                ast.Name(id="response")
            ],
            value=ast.Call(
                func=ast.Attribute(value=requestor, attr=method, ctx=ast.Load()),
                args=[self.gen_expr(req.url)],
                keywords=[ast.keyword(arg=name, value=self.gen_expr(value))
                          for name, value in iteritems(named_args)],
                starargs=None,
                kwargs=None
            )))

        lines.extend(self._gen_assertions(req))
        lines.extend(self._gen_jsonpath_assertions(req))
        lines.extend(self._gen_xpath_assertions(req))

        lines.extend(self._gen_extractors(req))

        if think_time:
            lines.append(
                ast.Expr(
                    ast.Call(
                        func=ast.Attribute(
                            value=ast.Name(id="time", ctx=ast.Load()),
                            attr="sleep",
                            ctx=ast.Load()),
                        args=[self.gen_expr(think_time)],
                        keywords=[],
                        starargs=None,
                        kwargs=None)))
        return lines

    def _gen_default_vars(self):
        variables = self.scenario.get("variables")
        values = ast.Dict(
            keys=[self.expr_compiler.gen_expr(key) for key, _ in iteritems(variables)],
            values=[self.expr_compiler.gen_expr(value) for _, value in iteritems(variables)])

        return ast.Assign(targets=[ast.Name(id='vars', ctx=ast.Store())], value=values)

    def _gen_assertions(self, request):
        stmts = []
        assertions = request.config.get("assert", [])
        for idx, assertion in enumerate(assertions):
            assertion = ensure_is_dict(assertions, idx, "contains")
            if not isinstance(assertion['contains'], list):
                assertion['contains'] = [assertion['contains']]
            subject = assertion.get("subject", Scenario.FIELD_BODY)
            if subject in (Scenario.FIELD_BODY, Scenario.FIELD_HEADERS):
                for member in assertion["contains"]:
                    func_table = {
                        (Scenario.FIELD_BODY, False, False): "assert_in_body",
                        (Scenario.FIELD_BODY, False, True): "assert_not_in_body",
                        (Scenario.FIELD_BODY, True, False): "assert_regex_in_body",
                        (Scenario.FIELD_BODY, True, True): "assert_regex_not_in_body",
                        (Scenario.FIELD_HEADERS, False, False): "assert_in_headers",
                        (Scenario.FIELD_HEADERS, False, True): "assert_not_in_headers",
                        (Scenario.FIELD_HEADERS, True, False): "assert_regex_in_headers",
                        (Scenario.FIELD_HEADERS, True, True): "assert_regex_not_in_headers",
                    }
                    method = func_table[(subject, assertion.get('regexp', True), assertion.get('not', False))]
                    stmts.append(ast.Expr(
                        ast.Call(
                            func=ast.Attribute(
                                value=ast.Name(id="response", ctx=ast.Load()),
                                attr=method,
                                ctx=ast.Load()
                            ),
                            args=[self.gen_expr(member)],
                            keywords=[],
                            starargs=None,
                            kwargs=None
                        )
                    ))
            elif subject == Scenario.FIELD_RESP_CODE:
                for member in assertion["contains"]:
                    method = "assert_status_code" if not assertion.get('not', False) else "assert_not_status_code"
                    stmts.append(ast.Expr(
                        ast.Call(
                            func=ast.Attribute(
                                value=ast.Name(id="response", ctx=ast.Load()),
                                attr=method,
                                ctx=ast.Load()
                            ),
                            args=[self.gen_expr(member)],
                            keywords=[],
                            starargs=None,
                            kwargs=None
                        )
                    ))
        return stmts

    def _gen_jsonpath_assertions(self, request):
        stmts = []
        jpath_assertions = request.config.get("assert-jsonpath", [])
        for idx, assertion in enumerate(jpath_assertions):
            assertion = ensure_is_dict(jpath_assertions, idx, "jsonpath")
            exc = TaurusConfigError('JSON Path not found in assertion: %s' % assertion)
            query = assertion.get('jsonpath', exc)
            expected = assertion.get('expected-value', None)
            method = "assert_not_jsonpath" if assertion.get('invert', False) else "assert_jsonpath"
            stmts.append(ast.Expr(
                ast.Call(
                    func=ast.Attribute(
                        value=ast.Name(id="response", ctx=ast.Load()),
                        attr=method,
                        ctx=ast.Load()
                    ),
                    args=[self.gen_expr(query)],
                    keywords=[ast.keyword(arg="expected_value", value=self.gen_expr(expected))],
                    starargs=None,
                    kwargs=None
                )
            ))

        return stmts

    def _gen_xpath_assertions(self, request):
        stmts = []
        jpath_assertions = request.config.get("assert-xpath", [])
        for idx, assertion in enumerate(jpath_assertions):
            assertion = ensure_is_dict(jpath_assertions, idx, "xpath")
            exc = TaurusConfigError('XPath not found in assertion: %s' % assertion)
            query = assertion.get('xpath', exc)
            parser_type = 'html' if assertion.get('use-tolerant-parser', True) else 'xml'
            validate = assertion.get('validate-xml', False)
            method = "assert_not_xpath" if assertion.get('invert', False) else "assert_xpath"
            stmts.append(ast.Expr(
                ast.Call(
                    func=ast.Attribute(
                        value=ast.Name(id="response", ctx=ast.Load()),
                        attr=method,
                        ctx=ast.Load()
                    ),
                    args=[self.gen_expr(query)],
                    keywords=[ast.keyword(arg="parser_type", value=self.gen_expr(parser_type)),
                              ast.keyword(arg="validate", value=self.gen_expr(validate))],
                    starargs=None,
                    kwargs=None
                )
            ))

        return stmts

    def _gen_extractors(self, request):
        stmts = []
        jextractors = request.config.get("extract-jsonpath")
        for varname in jextractors:
            cfg = ensure_is_dict(jextractors, varname, "jsonpath")
            stmts.append(ast.Assign(
                targets=[self.expr_compiler.gen_var_accessor(varname, ast.Store())],
                value=ast.Call(
                    func=ast.Attribute(
                        value=ast.Name(id="response", ctx=ast.Load()),
                        attr="extract_jsonpath",
                        ctx=ast.Load()
                    ),
                    args=[self.gen_expr(cfg['jsonpath']), self.gen_expr(cfg.get('default', 'NOT_FOUND'))],
                    keywords=[],
                    starargs=None,
                    kwargs=None
                )
            ))

        extractors = request.config.get("extract-regexp")
        for varname in extractors:
            cfg = ensure_is_dict(extractors, varname, "regexp")
            # TODO: support non-'body' value of 'subject'
            stmts.append(ast.Assign(
                targets=[self.expr_compiler.gen_var_accessor(varname, ast.Store())],
                value=ast.Call(
                    func=ast.Attribute(
                        value=ast.Name(id="response", ctx=ast.Load()),
                        attr="extract_regex",
                        ctx=ast.Load()
                    ),
                    args=[self.gen_expr(cfg['regexp']), self.gen_expr(cfg.get('default', 'NOT_FOUND'))],
                    keywords=[],
                    starargs=None,
                    kwargs=None
                )
            ))

        # TODO: css/jquery extractor?

        xpath_extractors = request.config.get("extract-xpath")
        for varname in xpath_extractors:
            cfg = ensure_is_dict(xpath_extractors, varname, "xpath")
            parser_type = 'html' if cfg.get('use-tolerant-parser', True) else 'xml'
            validate = cfg.get('validate-xml', False)
            stmts.append(ast.Assign(
                targets=[self.expr_compiler.gen_var_accessor(varname, ast.Store())],
                value=ast.Call(
                    func=ast.Attribute(
                        value=ast.Name(id="response", ctx=ast.Load()),
                        attr="extract_xpath",
                        ctx=ast.Load()
                    ),
                    args=[self.gen_expr(cfg['xpath'])],
                    keywords=[ast.keyword(arg="default", value=cfg.get('default', 'NOT_FOUND')),
                              ast.keyword(arg="parser_type", value=parser_type),
                              ast.keyword(arg="validate", value=validate)],
                    starargs=None,
                    kwargs=None,
                )
            ))

        return stmts

    def build_tree(self):
        mod = self._gen_module()
        mod.lineno = 0
        mod.col_offset = 0
        mod = ast.fix_missing_locations(mod)
        return mod

    def build_source_code(self):
        self.tree = self.build_tree()

    def save(self, filename):
        with open(filename, 'wt') as fds:
            source = astunparse.unparse(self.tree)
            # because astunparse on Python 2 adds extra comma+space
            class_name = create_class_name(self.label)
            source = source.replace('class %s(unittest.TestCase, )' % class_name,
                                    'class %s(unittest.TestCase)' % class_name)
            fds.write(source)

    def _gen_logging(self):
        set_log = ast.Assign(targets=[ast.Name(id="log")], value=ast.Call(
                func=ast.Attribute(
                    value=ast.Name(id="logging"),
                    attr="getLogger"),
                args=[ast.Str(s="apiritif.http")],
                keywords=[],
                starargs=None,
                kwargs=None))
        add_handler = ast.Call(
            func=ast.Attribute(
                value=ast.Name(id="log"),
                attr="addHandler"),
            args=[ast.Call(
                    func=ast.Attribute(value=ast.Name(id="logging"), attr="StreamHandler"),
                    args=[ast.Attribute(value=ast.Name(id="sys"), attr="stdout")],
                    keywords=[],
                    starargs=None,
                    kwargs=None)],
            keywords=[],
            starargs=None,
            kwargs=None
        )
        set_level = ast.Call(
            func=ast.Attribute(value=ast.Name(id="log"), attr="setLevel"),
            args=[ast.Attribute(value=ast.Name(id="logging"), attr="DEBUG")],
            keywords=[],
            starargs=None,
            kwargs=None)

        return [set_log, self._gen_empty_line_stmt(), add_handler,
                self._gen_empty_line_stmt(), set_level, self._gen_empty_line_stmt()]
